<div class="main-section wf-section"> 
  <div class="side-menu"> 
   <img src="assets/images/logo.png" alt="" class="image1" srcset=""> 
   <div class="text1 text6 text7 text10 text11 text14">
     IT CONSULTANT 
   </div> 
   <div class="text1 text6 text10">
     PERRY ANDERSON 
   </div> 
   <a href="http://www.exparx.com/" target="_blank" class="link w-inline-block"> 
    <div class="text1 text6 text7 text10 text11 text14 text40">
      E X P A R X, I N C. 
    </div> </a> 
   <ul role="list" class="list0"> 
    <li class="list1"> <a class="link1" routerLink="/">Perry Anderson</a> </li> 
    <li> <a class="link1" routerLink="/portfolio">Portfolio</a> </li> 
    <li> <a class="link1" routerLink="/story">My Story</a> </li> 
    <li> <a class="link1 hide" routerLink="/gof_design_patterns">GoF Design Patterns</a> </li> 
    <li> <a class="link1" routerLink="/best_practices_it">Best Practices, (IT)</a> </li> 
    <li> <a class="link1" routerLink="/crc_32bit_collision">CRC 32bit Collision</a> </li> 
    <li> <a class="link1" routerLink="/gof_abstract_factory_pattern">Design by Interface<br>‍</a> </li> 
    <li> <a aria-current="page" class="link1 w--current" routerLink="/bloomberg">Bloomberg Interview</a> </li> 
    <li> <a class="link1" routerLink="/amazon">Amazon Interview</a> </li> 
    <li> <a class="link1" routerLink="/amazon_2">Amazon Interview #2<br>‍</a> </li> 
    <li> <a class="link1" routerLink="/privacy_policy">Privacy Policy</a> </li> 
    <li> <a href="https://www.youtube.com/watch?v=BywDOO99Ia0" target="_blank" class="link1">Coffee Shop Music</a> </li> 
    <li> <a class="link1" routerLink="/contact">Contact</a> </li> 
   </ul> 
  </div> 
  <div class="right-area left-area"> 
   <div> 
    <div class="text0 large-caps">
      Bloomberg 
    </div> 
    <div class="text0 large-caps">
      Interview 
    </div> 
    <div class="text0 paragraph t3">
      Merge Two Sorted Lists, LeetCode OJ 
    </div> 
    <div class="explantion">
      Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. ( Source: 
     <a target="_blank" href="https://leetcode.com/problems/merge-two-sorted-lists/">LeetCode OJ</a> ) 
    </div> 
    <img src="assets/images/test.png" sizes="(max-width: 479px) 100vw, 563px" srcset="assets/images/test-p-500x332.png 500w, assets/images/test.png 737w" alt="" class="i33"> 
    <div class="text0 paragraph t3">
      Merge Two Sorted Lists, Solutions 
    </div> 
    <div data-duration-in="300" data-duration-out="100" data-current="Tab 1" data-easing="ease" class="b1 w-tabs"> 
     <div class="w-tab-menu"> 
      <a data-w-tab="Tab 1" class="w-inline-block w-tab-link " [ngClass]="{'w--current' : selector1==1}" (click)="selector1=1"> 
       <div>
         #1 
       </div> </a> 
      <a data-w-tab="Tab 2" class="w-inline-block w-tab-link" [ngClass]="{'w--current' : selector1==2}" (click)="selector1=2"> 
       <div>
         #2 
       </div> </a> 
      <a data-w-tab="Tab 3" class="w-inline-block w-tab-link" [ngClass]="{'w--current' : selector1==3}" (click)="selector1=3"> 
       <div>
         #3 
       </div> </a> 
      <a data-w-tab="Tab 4" class="w-inline-block w-tab-link" [ngClass]="{'w--current' : selector1==4}" (click)="selector1=4"> 
       <div>
         #4 
       </div> </a> 
      <a data-w-tab="Tab 5" class="w-inline-block w-tab-link" [ngClass]="{'w--current' : selector1==5}" (click)="selector1=5"> 
       <div>
         #5 
       </div> </a> 
      <a data-w-tab="Tab 6" class="w-inline-block w-tab-link" [ngClass]="{'w--current' : selector1==6}" (click)="selector1=6"> 
       <div>
         #6 
       </div> </a> 
      <a data-w-tab="Tab 7" class="w-inline-block w-tab-link" [ngClass]="{'w--current' : selector1==7}" (click)="selector1=7"> 
       <div>
         #7 
       </div> </a> 
     </div> 
     <div class="w-tab-content"> 
      <div data-w-tab="Tab 1" class="w-tab-pane " [ngClass]="{'w--tab-active' : selector1==1}" [hidden]="selector1==1"> 
       <h4 class="h33">Solution #1: Classic STL Solution, Immutable parameters</h4> 
       <div class="explantion">
         The following image is a snap shot of the solution developed using the Xcode 7.2.1 IDE and the results given by LeetCode OJ: 
       </div> 
       <div class="m1"> 
        <img src="assets/images/Screen-Shot-2016-03-09-at-7.42.47-PM.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/Screen-Shot-2016-03-09-at-7.42.47-PM-p-500x282.png 500w, assets/images/Screen-Shot-2016-03-09-at-7.42.47-PM-p-800x450.png 800w, assets/images/Screen-Shot-2016-03-09-at-7.42.47-PM-p-1080x608.png 1080w, assets/images/Screen-Shot-2016-03-09-at-7.42.47-PM-p-1600x900.png 1600w, assets/images/Screen-Shot-2016-03-09-at-7.42.47-PM.png 2560w" alt="" class="t4"> 
        <h5 class="h22">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         When first looking at this problem I wondered if it would be possible to simply iterate down each of the link lists and make the appropriate connections based on the links already established in the list. Within a very short amount of time I realized that this is precisely what the STL framework was meant to address. So I quickly changed everything in light of a typical STL application for a problem such as this. One thing I overlooked in this task was that the lists to be merged were already sorted. I mistakenly assumed that they were not going to be sorted and developed a solution that sorted the lists from inside the method. Turns out I ended up hitting two birds with one stone, this is typical of applications written using STL in my experience. Within an hour I had a most elegant solution based on the STL framework: 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #1</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> std::list&lt;int&gt; intList;</p> 
         <p> ListNode* h1 = l1, *h2 = l2;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> intList.push_back(h1-&gt;val);</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> intList.push_back(h2-&gt;val);</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> ListNode* listNode = new ListNode(0), *p = listNode, *result = listNode;</p> 
         <p> intList.sort();</p> 
         <p> std::list&lt;int&gt;::const_iterator iterator;</p> 
         <p> for (iterator = intList.begin(); iterator != intList.end(); ++iterator) {{"{"}}</p> 
         <p> int value = *iterator;</p> 
         <p> p = listNode;</p> 
         <p> listNode-&gt;val = value;</p> 
         <p> listNode = new ListNode(0);</p> 
         <p> p-&gt;next = listNode;</p> 
         <p> {{"}"}}</p> 
         <p> p-&gt;next = NULL;</p> 
         <p> if ( p == listNode ) {{"{"}}</p> 
         <p> delete listNode;</p> 
         <p> return NULL;</p> 
         <p> {{"}"}}</p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         Essentially what we do is read the values of both linked lists an place them inside an STL list container. From there we merely do a simply sort of int values before creating a new link list containing the sorted values to be passed back to the client. Here we make use of the typical STL container classes such as std::list and for transversing the list we use the classic STL iterator. The standard built-in STL list.sort() utilizes it's default sorting algorithm.<br><br>When I submitted my solution to the LeetCode OJ database for approval I was rather surprised to see a graph comparing my results with many others. Unfortunately for me I misread the rating on the report that suggested that my solution may not be the most efficient: 
       </div> 
       <img src="assets/images/report.png" alt="" class="report" srcset=""> 
       <div class="explantion">
         I was further confused by the layout of the graph that seemed to suggest that some people were able to submit a solution many, many times faster than mine. Curious as to how I could improve on my simple and elegant STL solution I decided to alter the solution to make use of classic optimizations often associated with C/C++ performance and memory issues. 
       </div> 
       <div class="m1"> 
        <img src="assets/images/graph1.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/graph1-p-500x276.png 500w, assets/images/graph1.png 1169w" alt="" class="t4"> 
        <h5 class="h22 h23">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         Based on what I was reading from the above graph I became so curious as to how I could make my solution much more efficient. In this LeetCode OJ example it is merely a case of merging two link lists but in real world C++ applications it might be a situation where performance and resources become an issue. With over 320,000 total submissions and over 110,000 total accepted solutions, I wanted to know if what I was reading from the graph was accurate seeing how I basically applying STL in a classic manner to address this problem. I really wanted to know if a standard STL solution was going to be adequate or if a more generic approach could produce better results. So I decided to apply techniques that I learned from previous real world C++ application development to see if I could improve my rating. 
       </div> 
      </div> 
      <div data-w-tab="Tab 2" class="w-tab-pane" [ngClass]="{'w--tab-active' : selector1==2}" [hidden]="selector1==2"> 
       <h4 class="h33">Solution #2: Classic Heap Sort Solution, Immutable parameters</h4> 
       <div class="explantion">
         The following image is a snap shot of the 2nd solution developed and the results given by LeetCode OJ: 
       </div> 
       <div class="m1"> 
        <img src="assets/images/Screen-Shot-2016-03-09-at-7.48.11-PM.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/Screen-Shot-2016-03-09-at-7.48.11-PM-p-500x282.png 500w, assets/images/Screen-Shot-2016-03-09-at-7.48.11-PM-p-800x450.png 800w, assets/images/Screen-Shot-2016-03-09-at-7.48.11-PM-p-1080x608.png 1080w, assets/images/Screen-Shot-2016-03-09-at-7.48.11-PM-p-1600x900.png 1600w, assets/images/Screen-Shot-2016-03-09-at-7.48.11-PM.png 2560w" alt="" class="t4"> 
        <h5 class="h22">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         My second solution to this problem didn't take all that long to do compared to my first attempt to come up with a solution, perhaps a mere 1/2 hour at most. Here, I simply remove all references to the STL framework and in it's place put in a classic heap sort solution based on arrays: 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #2</p> 
         <p>void MAX_HEAPIFY(int a[], int i, int n)</p> 
         <p>{{"{"}}</p> 
         <p> int l,r,largest,loc;</p> 
         <p> l=2*i;</p> 
         <p> r=(2*i+1);</p> 
         <p> if((l&lt;=n)&amp;&amp;a[l]&gt;a[i])</p> 
         <p> largest=l;</p> 
         <p> else</p> 
         <p> largest=i;</p> 
         <p> if((r&lt;=n)&amp;&amp;(a[r]&gt;a[largest]))</p> 
         <p> largest=r;</p> 
         <p> if(largest!=i)</p> 
         <p> {{"{"}}</p> 
         <p> loc=a[i];</p> 
         <p> a[i]=a[largest];</p> 
         <p> a[largest]=loc;</p> 
         <p> MAX_HEAPIFY(a, largest,n);</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}}</p> 
         <p>void BUILD_MAX_HEAP(int a[], int n)</p> 
         <p>{{"{"}}</p> 
         <p> for(int k = n/2; k &gt;= 1; k--)</p> 
         <p> {{"{"}}</p> 
         <p> MAX_HEAPIFY(a, k, n);</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}}</p> 
         <p>void HEAPSORT(int a[], int n)</p> 
         <p>{{"{"}}</p> 
         <p> </p> 
         <p> BUILD_MAX_HEAP(a,n);</p> 
         <p> int i, temp;</p> 
         <p> for (i = n; i &gt;= 2; i--)</p> 
         <p> {{"{"}}</p> 
         <p> temp = a[i];</p> 
         <p> a[i] = a[1];</p> 
         <p> a[1] = temp;</p> 
         <p> MAX_HEAPIFY(a, 1, i - 1);</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}}</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> ListNode* h1 = l1, *h2 = l2;</p> 
         <p> int n = 0;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> n++;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> n++;</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> h1 = l1, h2 = l2;</p> 
         <p> int a[n], i=1;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> a[i++] = h1-&gt;val;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> a[i++] = h2-&gt;val;</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> HEAPSORT(a, n);</p> 
         <p> ListNode* listNode = new ListNode(0), *p = listNode, *result = listNode;</p> 
         <p> for (int i = 1; i &lt;= n; i++) {{"{"}}</p> 
         <p> int value = a[i];</p> 
         <p> p = listNode;</p> 
         <p> listNode-&gt;val = value;</p> 
         <p> listNode = new ListNode(0);</p> 
         <p> p-&gt;next = listNode;</p> 
         <p> {{"}"}}</p> 
         <p> p-&gt;next = NULL;</p> 
         <p> if ( p == listNode ) {{"{"}}</p> 
         <p> delete listNode;</p> 
         <p> return NULL;</p> 
         <p> {{"}"}}</p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         Here I borrowed a readily available implementation of a typical heap sort compliments a Avi Dhall on 
        <a href="http://www.coders-hub.com/2015/02/heap-sort-using-c.html#.VuB_qceT5Ec" target="_blank">coders-hub.com</a>. To get the int values from the link lists I have to add additional code to first figure out how long both lists are, then create an int array to hold all the int values. With this information I merely call the heap sort out of the box and then place the sorted array into a brand new link list to be passed back to the client.<br><br>What amazed me however is that the benchmarks provided by LeetCode OJ were practically identical to the original STL solution. 
       </div> 
       <div class="m1"> 
        <img src="assets/images/graph2.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/graph2-p-500x284.png 500w, assets/images/graph2-p-800x453.png 800w, assets/images/graph2.png 1164w" alt="" class="t4"> 
        <h5 class="h22 h23">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         Thinking that perhaps I wasn't using the most efficient sorting algorithm I quickly tracked down a quick sort solution and made the appropriate changes. My justification for going through this trouble is that there remained a possibility that my solution was being tested against an extensive test suite where such issues as sorting algorithms would play a major role in the outcome of the solutions performance. For example in testing I am using a mere 10 ints each in two linked lists. But how would this solution perform if we had perhaps 100,000 ints or even a million ints to compare. I made the assumption that the test suite may be testing my solution against such a situation. 
       </div> 
      </div> 
      <div data-w-tab="Tab 3" class="w-tab-pane" [ngClass]="{'w--tab-active' : selector1==3}" [hidden]="selector1==3"> 
       <h4 class="h33">Solution #3: Classic Quick Sort Solution, Immutable parameters</h4> 
       <div class="explantion">
         The following image is a snap shot of the 3rd solution developed and the results given by LeetCode OJ: 
       </div> 
       <div class="m1"> 
        <img src="assets/images/Screen-Shot-2016-03-09-at-7.49.29-PM.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/Screen-Shot-2016-03-09-at-7.49.29-PM-p-500x282.png 500w, assets/images/Screen-Shot-2016-03-09-at-7.49.29-PM-p-800x450.png 800w, assets/images/Screen-Shot-2016-03-09-at-7.49.29-PM-p-1080x608.png 1080w, assets/images/Screen-Shot-2016-03-09-at-7.49.29-PM-p-1600x900.png 1600w, assets/images/Screen-Shot-2016-03-09-at-7.49.29-PM.png 2560w" alt="" class="t4"> 
        <h5 class="h22">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         My third solution to this problem was a simple exchange of sorting algorithms however finding a quick sort algorithm online that was properly tested took a few attempts as the LeetCode OJ test suite kept spitting out subtle problems with a couple test cases. Again this is a none-STL solution applying a classic quick sort solution based on arrays: 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #3</p> 
         <p>int partition(int *arr, const int left, const int right) {{"{"}}</p> 
         <p> const int mid = left + (right - left) / 2;</p> 
         <p> const int pivot = arr[mid];</p> 
         <p> // move the mid point value to the front.</p> 
         <p> std::swap(arr[mid],arr[left]);</p> 
         <p> int i = left + 1;</p> 
         <p> int j = right;</p> 
         <p> while (i &lt;= j) {{"{"}}</p> 
         <p> while(i &lt;= j &amp;&amp; arr[i] &lt;= pivot) {{"{"}}</p> 
         <p> i++;</p> 
         <p> {{"}"}} </p> 
         <p> while(i &lt;= j &amp;&amp; arr[j] &gt; pivot) {{"{"}}</p> 
         <p> j--;</p> 
         <p> {{"}"}}</p> 
         <p> if (i &lt; j) {{"{"}}</p> 
         <p> std::swap(arr[i], arr[j]);</p> 
         <p> {{"}"}}</p> 
         <p> {{"}"}}</p> 
         <p> std::swap(arr[i - 1],arr[left]);</p> 
         <p> return i - 1;</p> 
         <p>{{"}"}}</p> 
         <p>void quicksort(int *arr, const int left, const int right, const int sz){{"{"}}</p> 
         <p> if (left &gt;= right) {{"{"}}</p> 
         <p> return;</p> 
         <p> {{"}"}}</p> 
         <p> int part = partition(arr, left, right);</p> 
         <p> quicksort(arr, left, part - 1, sz);</p> 
         <p> quicksort(arr, part + 1, right, sz);</p> 
         <p>{{"}"}}</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> ListNode* h1 = l1, *h2 = l2;</p> 
         <p> int n = 0;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> n++;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> n++;</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> h1 = l1, h2 = l2;</p> 
         <p> int a[n], i=0;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> a[i++] = h1-&gt;val;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> a[i++] = h2-&gt;val;</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> quicksort(a, 0, n - 1, n);</p> 
         <p> ListNode* listNode = new ListNode(0), *p = listNode, *result = listNode;</p> 
         <p> for (int i = 0; i &lt; n; i++) {{"{"}}</p> 
         <p> int value = a[i];</p> 
         <p> p = listNode;</p> 
         <p> listNode-&gt;val = value;</p> 
         <p> listNode = new ListNode(0);</p> 
         <p> p-&gt;next = listNode;</p> 
         <p> {{"}"}}</p> 
         <p> p-&gt;next = NULL;</p> 
         <p> if ( p == listNode ) {{"{"}}</p> 
         <p> delete listNode;</p> 
         <p> return NULL;</p> 
         <p> {{"}"}}</p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         Here I borrowed a readily available implementation of a typical heap sort compliments ROLFL on 
        <a target="_blank" href="http://codereview.stackexchange.com/questions/77782/quick-sort-implementation">StackExchange</a>. To get the int values from the link lists I have to add additional code to first figure out how long both lists are, then create an int array to hold all the int values. With this information I merely call the heap sort out of the box and then place the sorted array into a brand new link list to be passed back to the client.<br><br>Despite utilizing a different, more efficient sorting algorithm however there was almost no change in the performance reported by LeetCode OJ: 
       </div> 
       <div class="m1"> 
        <img src="assets/images/graph3.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/graph3-p-500x279.png 500w, assets/images/graph3-p-800x447.png 800w, assets/images/graph3.png 1171w" alt="" class="t4"> 
        <h5 class="h22 h23">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         So this led me to believe that perhaps it was a memory utilization issue. That perhaps by eliminating the need to create a new link list I might be able to expedite the execution of the code. Essentially, what I would do is simply connect and reload the link lists passed as parameters with the sorted results as oppose to creating a third linked list. 
       </div> 
      </div> 
      <div data-w-tab="Tab 4" class="w-tab-pane" [ngClass]="{'w--tab-active' : selector1==4}" [hidden]="selector1==4"> 
       <h4 class="h33">Solution #4: Classic STL Solution, Mutable parameters</h4> 
       <div class="explantion">
         The following image is a snap shot of the 4th solution developed and the results given by LeetCode OJ: 
       </div> 
       <div class="m1"> 
        <img src="assets/images/Screen-Shot-2016-03-10-at-11.59.20-AM.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/Screen-Shot-2016-03-10-at-11.59.20-AM-p-500x282.png 500w, assets/images/Screen-Shot-2016-03-10-at-11.59.20-AM-p-800x450.png 800w, assets/images/Screen-Shot-2016-03-10-at-11.59.20-AM-p-1080x608.png 1080w, assets/images/Screen-Shot-2016-03-10-at-11.59.20-AM-p-1600x900.png 1600w, assets/images/Screen-Shot-2016-03-10-at-11.59.20-AM.png 2560w" alt="" class="t4"> 
        <h5 class="h22">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         My forth solution was a step back to the original STL solution (#1) however this time rather than creating a third link list, I'd simply connect the two linked lists passed as arguments then reload the link lists with the sorted int values. Constructing the code for this technique was a bit tricky and took longer than expected due to the many variable dancing around the code. However with Xcode's debugging facilities I was able to track down the correct variables for the correct purposes in time. 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #4 (optimized)</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> if ( l1 == NULL &amp;&amp; l2 == NULL ) {{"{"}}</p> 
         <p> return NULL;</p> 
         <p> {{"}"}}</p> 
         <p> std::list&lt;int&gt; intList;</p> 
         <p> ListNode* h1 = l1, *h2 = l2;</p> 
         <p> ListNode* p1 = l1, *p2 = l2;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> intList.push_back(h1-&gt;val);</p> 
         <p> p1 = h1;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> intList.push_back(h2-&gt;val);</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> intList.sort();</p> 
         <p> if ( p1 != NULL &amp;&amp; p2 != NULL ) {{"{"}}</p> 
         <p> p1-&gt;next = p2;</p> 
         <p> {{"}"}}</p> 
         <p> if ( l1 == NULL &amp;&amp; l2 != NULL ) {{"{"}}</p> 
         <p> l1 = l2;</p> 
         <p> {{"}"}}</p> 
         <p> ListNode* listNode = l1, *result = listNode;</p> 
         <p> std::list&lt;int&gt;::const_iterator iterator;</p> 
         <p> for (iterator = intList.begin(); iterator != intList.end(); ++iterator) {{"{"}}</p> 
         <p> int value = *iterator;</p> 
         <p> listNode-&gt;val = value;</p> 
         <p> listNode = listNode-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         The result was a much shorter solution albeit a lot of concentration necessary to coordinate all the variables required. Further, this design kind of violates a cleaner coding practise of mine not to change the parameters which is what I am doing here. In the old C programming days it was much more common to change values inside the parameters that were passed to a function, with the introduction of more modern object-oriented tools like C++ and Java this practice became somewhat shunned except under exceptional circumstances. Essentially a function should begin at the top and exit at the bottom. Changing the solution to utilize the linked lists already in memory, while eliminating the need for allocating a new linked list, breaks this design convention. However, if ever we were faced with memory limitation issues this solution would work, where as the other solution would not. 
       </div> 
       <div class="m1"> 
        <img src="assets/images/graph4b.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/graph4b-p-500x290.png 500w, assets/images/graph4b-p-800x464.png 800w, assets/images/graph4b.png 1178w" alt="" class="t4"> 
        <h5 class="h22 h23">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         Despite the work I put into making these changes however, the resulting solution 
        <em data-new-link="true">was reported</em> to actually work slower, that is, according to LeetCode OJ's benchmarks. At the time I tested this solution however, I didn't realize I may have been reading the benchmark chart incorrectly. However, the fact that this benchmark had a very low red bar suggested to me that it had utilized far less memory resources as I had earlier. But I couldn't understand why this solution wasn't faster than before. So after some thought I decided to again try this approach albeit without utilizing the STL library. 
       </div> 
      </div> 
      <div data-w-tab="Tab 5" class="w-tab-pane" [ngClass]="{'w--tab-active' : selector1==5}" [hidden]="selector1==5"> 
       <h4 class="h33">Solution #5: Classic Quick Sort Solution, Mutable parameters</h4> 
       <div class="explantion">
         The following image is a snap shot of the 5th solution developed and the results given by LeetCode OJ: 
       </div> 
       <div class="m1"> 
        <img src="assets/images/Screen-Shot-2016-03-09-at-7.56.14-PM.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/Screen-Shot-2016-03-09-at-7.56.14-PM-p-500x282.png 500w, assets/images/Screen-Shot-2016-03-09-at-7.56.14-PM-p-800x450.png 800w, assets/images/Screen-Shot-2016-03-09-at-7.56.14-PM-p-1080x608.png 1080w, assets/images/Screen-Shot-2016-03-09-at-7.56.14-PM-p-1600x900.png 1600w, assets/images/Screen-Shot-2016-03-09-at-7.56.14-PM.png 2560w" alt="" class="t4"> 
        <h5 class="h22">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         My fifth solution was a step back to the quick sort solution (#3) . It is essentially the same as the forth solution except I am using arrays instead of the STL. I didn't have to trouble shoot this one as much as the forth solution, just carefully replace the STL functionality with a more generic approach using only arrays and the classic quick sort. 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #5</p> 
         <p>int partition(int *arr, const int left, const int right) {{"{"}}</p> 
         <p> const int mid = left + (right - left) / 2;</p> 
         <p> const int pivot = arr[mid];</p> 
         <p> // move the mid point value to the front.</p> 
         <p> std::swap(arr[mid],arr[left]);</p> 
         <p> int i = left + 1;</p> 
         <p> int j = right;</p> 
         <p> while (i &lt;= j) {{"{"}}</p> 
         <p> while(i &lt;= j &amp;&amp; arr[i] &lt;= pivot) {{"{"}}</p> 
         <p> i++;</p> 
         <p> {{"}"}}</p> 
         <p> while(i &lt;= j &amp;&amp; arr[j] &gt; pivot) {{"{"}}</p> 
         <p> j--;</p> 
         <p> {{"}"}}</p> 
         <p> if (i &lt; j) {{"{"}}</p> 
         <p> std::swap(arr[i], arr[j]);</p> 
         <p> {{"}"}}</p> 
         <p> {{"}"}}</p> 
         <p> std::swap(arr[i - 1],arr[left]);</p> 
         <p> return i - 1;</p> 
         <p>{{"}"}}</p> 
         <p>void quicksort(int *arr, const int left, const int right, const int sz){{"{"}}</p> 
         <p> if (left &gt;= right) {{"{"}}</p> 
         <p> return;</p> 
         <p> {{"}"}}</p> 
         <p> int part = partition(arr, left, right);</p> 
         <p> quicksort(arr, left, part - 1, sz);</p> 
         <p> quicksort(arr, part + 1, right, sz);</p> 
         <p>{{"}"}}</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> ListNode* h1 = l1, *h2 = l2;</p> 
         <p> ListNode* p1 = l1, *p2 = l2;</p> 
         <p> int n = 0;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> n++;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> n++;</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> h1 = l1, h2 = l2;</p> 
         <p> int a[n], i=0;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> a[i++] = h1-&gt;val;</p> 
         <p> p1 = h1;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> a[i++] = h2-&gt;val;</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> if ( p1 != NULL &amp;&amp; p2 != NULL ) {{"{"}}</p> 
         <p> p1-&gt;next = p2;</p> 
         <p> {{"}"}}</p> 
         <p> if ( l1 == NULL &amp;&amp; l2 != NULL ) {{"{"}}</p> 
         <p> l1 = l2;</p> 
         <p> {{"}"}}</p> 
         <p> if ( l1 == NULL &amp;&amp; l2 == NULL ) {{"{"}}</p> 
         <p> return NULL;</p> 
         <p> {{"}"}}</p> 
         <p> quicksort(a, 0, n - 1, n);</p> 
         <p> ListNode* listNode = l1, *result = listNode;</p> 
         <p> for (int i = 0; i &lt; n; i++) {{"{"}}</p> 
         <p> int value = a[i];</p> 
         <p> listNode-&gt;val = value;</p> 
         <p> listNode = listNode-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         Essentially this solution manually tracks down the number of items in each list then creates an int array on the heap to store them for sorting. It also meticulously figures out where the end of the first list is and then connects to the start of the second list. It then sorts the ints and reloads them into the first list which is now both lists connected. 
       </div> 
       <div class="m1"> 
        <img src="assets/images/graph5.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/graph5-p-500x291.png 500w, assets/images/graph5-p-800x465.png 800w, assets/images/graph5.png 1176w" alt="" class="t4"> 
        <h5 class="h22 h23">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         This approach eliminates the need to allocate memory for a third link list or the need to delete the first two link lists. Which is great from a memory allocation standpoint which I thought would make all the difference as far as performance was concerned. The only real change in performance was that now the LeetCode OJ graph showed the same performance as before. This quick sort, non-STL solution seemed to be better but at this point I was beginning to doubt the accuracy of the performance data presented by LeetCode OJ. 
       </div> 
      </div> 
      <div data-w-tab="Tab 6" class="w-tab-pane" [ngClass]="{'w--tab-active' : selector1==6}" [hidden]="selector1==6"> 
       <h4 class="h33">Solution #6: Classic Heap Sort Solution, Mutable parameters</h4> 
       <div class="explantion">
         The following image is a snap shot of the 6th solution developed and the results given by LeetCode OJ: 
       </div> 
       <div class="m1"> 
        <img src="assets/images/Screen-Shot-2016-03-09-at-7.58.17-PM.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/Screen-Shot-2016-03-09-at-7.58.17-PM-p-500x282.png 500w, assets/images/Screen-Shot-2016-03-09-at-7.58.17-PM-p-800x450.png 800w, assets/images/Screen-Shot-2016-03-09-at-7.58.17-PM-p-1080x608.png 1080w, assets/images/Screen-Shot-2016-03-09-at-7.58.17-PM-p-1600x900.png 1600w, assets/images/Screen-Shot-2016-03-09-at-7.58.17-PM.png 2560w" alt="" class="t4"> 
        <h5 class="h22">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         My sixth solution was a step back to the heap sort solution (#2) . It is essentially the same as the forth solution except I am using arrays instead of the STL. I didn't have to trouble shoot this one as much as the forth solution, just carefully replace the STL functionality with a more generic approach using only arrays and the classic heap sort. I did this for argument sake just to see if there was any performance differences being detected by the LeetCode OJ test suite. 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #6</p> 
         <p>void MAX_HEAPIFY(int a[], int i, int n)</p> 
         <p>{{"{"}}</p> 
         <p> int l,r,largest,loc;</p> 
         <p> l=2*i;</p> 
         <p> r=(2*i+1);</p> 
         <p> if((l&lt;=n)&amp;&amp;a[l]&gt;a[i])</p> 
         <p> largest=l;</p> 
         <p> else</p> 
         <p> largest=i;</p> 
         <p> if((r&lt;=n)&amp;&amp;(a[r]&gt;a[largest]))</p> 
         <p> largest=r;</p> 
         <p> if(largest!=i)</p> 
         <p> {{"{"}}</p> 
         <p> loc=a[i];</p> 
         <p> a[i]=a[largest];</p> 
         <p> a[largest]=loc;</p> 
         <p> MAX_HEAPIFY(a, largest,n);</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}}</p> 
         <p>void BUILD_MAX_HEAP(int a[], int n)</p> 
         <p>{{"{"}}</p> 
         <p> for(int k = n/2; k &gt;= 1; k--)</p> 
         <p> {{"{"}}</p> 
         <p> MAX_HEAPIFY(a, k, n);</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}}</p> 
         <p>void HEAPSORT(int a[], int n)</p> 
         <p>{{"{"}}</p> 
         <p> BUILD_MAX_HEAP(a,n);</p> 
         <p> int i, temp;</p> 
         <p> for (i = n; i &gt;= 2; i--)</p> 
         <p> {{"{"}}</p> 
         <p> temp = a[i];</p> 
         <p> a[i] = a[1];</p> 
         <p> a[1] = temp;</p> 
         <p> MAX_HEAPIFY(a, 1, i - 1);</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}}</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> ListNode* h1 = l1, *h2 = l2;</p> 
         <p> ListNode* p1 = l1, *p2 = l2;</p> 
         <p> int n = 0;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> n++;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> n++;</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> h1 = l1, h2 = l2;</p> 
         <p> int a[n], i=1;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> a[i++] = h1-&gt;val;</p> 
         <p> p1 = h1;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> a[i++] = h2-&gt;val;</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> if ( p1 != NULL &amp;&amp; p2 != NULL ) {{"{"}}</p> 
         <p> p1-&gt;next = p2;</p> 
         <p> {{"}"}}</p> 
         <p> if ( l1 == NULL &amp;&amp; l2 != NULL ) {{"{"}}</p> 
         <p> l1 = l2;</p> 
         <p> {{"}"}}</p> 
         <p> if ( l1 == NULL &amp;&amp; l2 == NULL ) {{"{"}}</p> 
         <p> return NULL;</p> 
         <p> {{"}"}}</p> 
         <p> HEAPSORT(a, n);</p> 
         <p> ListNode* listNode = l1, *result = listNode;</p> 
         <p> for (int i = 1; i &lt;= n; i++) {{"{"}}</p> 
         <p> int value = a[i];</p> 
         <p> listNode-&gt;val = value;</p> 
         <p> listNode = listNode-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         The resulting graph from LeetCode OJ showed no difference in performance: 
       </div> 
       <div class="m1"> 
        <img src="assets/images/graph6.png" sizes="(max-width: 479px) 100vw, 539px" srcset="assets/images/graph6-p-500x279.png 500w, assets/images/graph6-p-800x447.png 800w, assets/images/graph6.png 1173w" alt="" class="t4"> 
        <h5 class="h22 h23">Right-click and "Save Image as ..." to get a better look at this image!</h5> 
       </div> 
       <div class="explantion">
         It was at this point that I began to realize that the original STL solution worked just fine!<br><br>Further that the message " 
        <em data-new-link="true">Your runtime beats 5.30% of cpp submissions.</em>" was misleading. In fact, a closer inspection of the graph provided by LeetCode OJ showed my solution in the top 94.7% bracket of posted solutions. It appears the graph was not entirely accurate based on the number of submissions, it was probably in err. For example, the graph goes from left to right where as the left of the graph indicates time of execution. My based on the 5.30% it was giving me, it suggested a lot of room for improvement when in effect, my solution was already in the top ten percent of submissions. 
       </div> 
      </div> 
      <div data-w-tab="Tab 7" class="w-tab-pane" [ngClass]="{'w--tab-active' : selector1==7}" [hidden]="selector1==7"> 
       <h4 class="h33">Solution #7: Intergrated STL/Quick Sort Solution, Mutable parameters</h4> 
       <div class="explantion">
         Before I realized I had been misinterpreting the LeetCode OJ data, I was giving serious thought to a possible 7th solution. One where I would combine the Quick Sort algorithm with both link lists in it's sorting process. Where I would simply change the values inside the link list nodes in the middle of the quick sort process. This of course I realize now would have been over kill but based on the data being presented to me I was so curious as to how everybody else seemed to be flying passed my solutions. Such a solution however would eliminate the need for maintaining a buffer of int values on the heap. If the link lists happen to contain millions of ints a solution such as this would be mandatory. 
       </div> 
       <h4 class="h33">Synopsis:</h4> 
       <div class="explantion">
         The long and short of this excursion shows that the STL library was not only the first solution to meet this challenge but also the most elegant: 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #1</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> std::list&lt;int&gt; intList;</p> 
         <p> ListNode* h1 = l1, *h2 = l2;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> intList.push_back(h1-&gt;val);</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> intList.push_back(h2-&gt;val);</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> ListNode* listNode = new ListNode(0), *p = listNode, *result = listNode;</p> 
         <p> intList.sort();</p> 
         <p> std::list&lt;int&gt;::const_iterator iterator;</p> 
         <p> for (iterator = intList.begin(); iterator != intList.end(); ++iterator) {{"{"}}</p> 
         <p> int value = *iterator;</p> 
         <p> p = listNode;</p> 
         <p> listNode-&gt;val = value;</p> 
         <p> listNode = new ListNode(0);</p> 
         <p> p-&gt;next = listNode;</p> 
         <p> {{"}"}}</p> 
         <p> p-&gt;next = NULL;</p> 
         <p> if ( p == listNode ) {{"{"}}</p> 
         <p> delete listNode;</p> 
         <p> return NULL;</p> 
         <p> {{"}"}}</p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         Anyone familiar with STL can easily recognize the solution provided hence it's maintainability is quite good. The only draw back on this solution has to do with environments where memory might be an issue. If for some reason we had an additional requirement where memory was limited then this alternative version using the same link lists passed in as parameters and linked together would work much better! However, there is a limitation even on this solution in the case of millions of link list entries. As the ints being sorted are being placed on the heap, hence only a raw link list solution (see below) which would not need a large heap would be required. 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #4 ( aka. Solution #1 version 2 )</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> if ( l1 == NULL &amp;&amp; l2 == NULL ) {{"{"}}</p> 
         <p> return NULL;</p> 
         <p> {{"}"}}</p> 
         <p> std::list&lt;int&gt; intList;</p> 
         <p> ListNode* h1 = l1, *h2 = l2;</p> 
         <p> ListNode* p1 = l1, *p2 = l2;</p> 
         <p> while ( h1!=NULL ) {{"{"}}</p> 
         <p> intList.push_back(h1-&gt;val);</p> 
         <p> p1 = h1;</p> 
         <p> h1 = h1-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> while ( h2!=NULL ) {{"{"}}</p> 
         <p> intList.push_back(h2-&gt;val);</p> 
         <p> h2 = h2-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> intList.sort();</p> 
         <p> if ( p1 != NULL &amp;&amp; p2 != NULL ) {{"{"}}</p> 
         <p> p1-&gt;next = p2;</p> 
         <p> {{"}"}}</p> 
         <p> if ( l1 == NULL &amp;&amp; l2 != NULL ) {{"{"}}</p> 
         <p> l1 = l2;</p> 
         <p> {{"}"}}</p> 
         <p> ListNode* listNode = l1, *result = listNode;</p> 
         <p> std::list&lt;int&gt;::const_iterator iterator;</p> 
         <p> for (iterator = intList.begin(); iterator != intList.end(); ++iterator) {{"{"}}</p> 
         <p> int value = *iterator;</p> 
         <p> listNode-&gt;val = value;</p> 
         <p> listNode = listNode-&gt;next;</p> 
         <p> {{"}"}}</p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         Further, this entire presentation has been based upon the assumption that the link lists are not sorted in the first place. Had they been sorted a more straightforward solution based merely on attaching both linked lists by way of iterating through them would be fine. If both lists are already sorted before hand then is problem becomes merely a text book example of how to manage link lists. 
        <em data-new-link="true">The solution you see below is not fully tested</em> but it has the general idea of how a solution for this problem would take place in the case of both lists sorted ahead of time. And what you see below you is the idea solution as no memory management issues are required as you as simply rewiring a link list already in memory, assuming mutable parameters.<br><br><strong data-new-link="true">Word to the wise: Know when to say when!</strong><br><em data-new-link="true">Design by Contract</em> is a popular concept among Eiffel programmers, essentially you determine ahead of time what a function has to do and you ensure that the function to be written only does what is expected. This includes checking the parameters for correct values before any processing takes place. The lesson to be gleaned from 
        <em data-new-link="true">Design by Contract</em> in my humble opinion is that get things done faster but making things simpler on yourself. Technically speaking, even though I didn't use a pure link list solution to this problem, by way of the STL I met the specification and delivered a working solution within an hour of the task at hand.<br><br><em data-new-link="true">Merge two sorted linked lists and return it as a new list. </em><br><br><em data-new-link="true">The new list should be made by splicing together the nodes of the first two lists.</em><br><br>The second version of Solution #1 meets both these requirements. Technically, by way of the STL framework, I have met the specification of this task. All in a days work!<br><br>The alternative method of piecing together a link list merge solution without the use of STL comparatively takes a lot longer given the many complications related to managing a link list. Based on what I read from Bjorne's ideals on why they developed the STL in the first place, I can easily appreciate today that if I had a boss that needed this done today there would be no contest, the STL solution gets things done. I say this out of experience. Quite often a boss needs a solution that works today and will quite often settle for an imperfect solution. It takes experience to know when to break down a problem in smaller parts to be delivered much more immediately as oppose to delaying progress while waiting for a more perfect solution.<br><br><strong data-new-link="true">Rational Unified Process</strong><br>Also, to those of you familiar with the Rational Unified Process and it's Iteration Drive Development methodology, both solutions can compliment each other quite nicely. In other words, in a professional environment, if the situation called for memory and performance efficient solution for the long term, then a shorter term STL solution can be established first, then time given for a more specific solution for the long term if the situation demanded it. 
       </div> 
       <h4 class="h33">Solution #8: Non-STL Merge solution assuming Two Sorted Lists</h4> 
       <div class="explantion">
         I am still so curious as to what LeetCode OJ considers 100%? When I find the time I will piece together a non-STL solution just to try to satisfy my curiosity. However, that being said, it generally takes a lot of time to piece together a solution like you see below and this demonstrates clearly how the use of the STL framework is a really great time saver. Hence, the original Solution #1 given in this presentation, while not the most memory efficient with respect to large case examples of millions of link list entries, is none the less far easily to implement and manage for smaller tasks that you generally see on a daily basis. Directly managing the internals of link lists are a hugely time consuming task, unless it is absolutely required due to exception circumstances, an out of the box STL solution is strongly recommended for most tasks. But for those of you who enjoy spending all day looking for needles in a haystack (which is what doing it without the use of STL is like) versus using a powerful magnet (which is what STL allows you to do) go for it. But after two hours of trying to piece together a none-STL solution to merging two sorted link lists without developing a complete set of proper test cases first, the solution presented earlier (See Solution #1 above) is strongly preferred and in fact far more practical. 
       </div> 
       <div class="m1"> 
        <div class="p1 w-richtext"> 
         <p>// Solution #8 ( incomplete )</p> 
         <p>class Solution {{"{"}}</p> 
         <p>public:</p> 
         <p> ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {{"{"}}</p> 
         <p> </p> 
         <p> if ( l1==NULL &amp;&amp; l2==NULL )</p> 
         <p> return NULL;</p> 
         <p> </p> 
         <p> if ( l1==NULL &amp;&amp; l2!=NULL )</p> 
         <p> return l2;</p> 
         <p> </p> 
         <p> if ( l1!=NULL &amp;&amp; l2==NULL )</p> 
         <p> return l1;</p> 
         <p> </p> 
         <p> ListNode* result = l1;</p> 
         <p> if ( l2-&gt;val &lt;= l1-&gt;val )</p> 
         <p> result = l2;</p> 
         <p> </p> 
         <p> while ( l1!=NULL &amp;&amp; l2!=NULL ) {{"{"}}</p> 
         <p> while ( l1!=NULL &amp;&amp; l2!=NULL &amp;&amp; l2-&gt;val &lt;= l1-&gt;val ) {{"{"}}</p> 
         <p> while ( l2-&gt;next!=NULL &amp;&amp; l2-&gt;next-&gt;val &lt;= l1-&gt;val )</p> 
         <p> l2 = l2-&gt;next;</p> 
         <p> ListNode* a = l1-&gt;next;</p> 
         <p> ListNode* b = l2-&gt;next;</p> 
         <p> l2-&gt;next = l1;</p> 
         <p> if ( b!=NULL )</p> 
         <p> l1-&gt;next = b;</p> 
         <p> l1 = a;</p> 
         <p> l2 = b;</p> 
         <p> {{"}"}}</p> 
         <p> while ( l1!=NULL &amp;&amp; l2!=NULL &amp;&amp; l2-&gt;val &gt; l1-&gt;val ) {{"{"}}</p> 
         <p> while ( l1-&gt;next!=NULL &amp;&amp; l1-&gt;next-&gt;val &lt; l2-&gt;val )</p> 
         <p> l1 = l1-&gt;next;</p> 
         <p> ListNode* a = l1-&gt;next;</p> 
         <p> ListNode* b = l2-&gt;next;</p> 
         <p> l1-&gt;next = l2;</p> 
         <p> if ( a!=NULL )</p> 
         <p> l1-&gt;next = a;</p> 
         <p> l1 = a;</p> 
         <p> l2 = b;</p> 
         <p> {{"}"}}</p> 
         <p> {{"}"}}</p> 
         <p> </p> 
         <p> return result;</p> 
         <p> {{"}"}}</p> 
         <p>{{"}"}};</p> 
        </div> 
       </div> 
       <div class="explantion">
         To go about developing a non-STL solution for this problem properly in a professional environment like Bloomberg, you'd want to develop a series of JUnit style test cases first. Which is essentially what the LeetCode OJ is providing in the background to run this solution against. This takes time and in some cases a considerable amount of time. It can be done of course but it's a bit like re-inventing the wheel. This is precisely the advantage of using STL. It takes all these standard data manipulating techniques and places them inside a template library for ease of reuse. In a world where getting things done fast and correctly is the order of the day, reinventing the wheel by tomorrow versus getting things done today is a choice few projects can go without! Unless there is something the STL is not already doing for you, your project leader is going to be a lot more satisfied with your work if you are using STL (imho). Furthermore, if your application depends on a lot of insertions and deletions then you'll find vector based solutions far more efficient than link lists due to fragmentation: 
       </div> 
       <img src="assets/images/vector-list-perf.png" alt="" class="p1 p2" srcset=""> 
       <div class="explantion"> 
        <a target="_blank" href="https://www.youtube.com/watch?v=YQs6IC-vgmo" class="l99">Why you should avoid Linked Lists, Bjarne Stroustrup<br></a> 
        <a target="_blank" href="https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style" class="l99">Day 1 Keynote, Bjarne Stroustrup: C++11 Style</a><br><br>What you have seen here is a typical day in software development for me. You utilize the tools you have available combined with what you understand as current and correct feedback. As for misunderstanding the task at hand "Merge Two 
        <em data-new-link="true">Sorted</em> Lists" it really doesn't matter as misunderstandings happen all the time. This is why we have the Rational Unified Process and Use Case driven development. In essence, the policy to make the time to take the time or vise-versa. To understand the customer better before any coding takes place as minor misunderstandings like this happen in life. However, the STL solution still solved both cases and did so within an hour, the only difference being that a pure non-STL solution might be more efficient. However, in real life, such efficiencies often come at the cost of time and money and in today's business world time is money. No where in the specification did the task at hand indicate that it had to be the fastest solution in the universe, hence I met the terms of the contract and saved my imaginary customer a tonne of money in consulting fees or lost production time. I was just curious as to why my solution wasn't considered near the top of the list as far as LeetCode OJ was concerned, hence the other versions of my solution. When time permits I will take the time to put in a proper non-STL version just to see if I hit a much higher rating. However I will also be noting just how long it took to put together said solution and compare the amount of time it took to re-invent the wheel verses my initial STL version which was completed within an hour of the task assignment. Had this been a real time engineering application, as is the case in my background in SCADA systems, this would have been a typical day at the office. To paraphrase the great 
        <em data-new-link="true"> Philippe Kahn: First you get it to work, then you get it to work better!</em><br><br>Thank you for taking the time to review this presentation.<br><br>Questions or comments on this solution can be provided in the section below. 
       </div> 
       <div> 
        <div class="skills-chart address"> 
         <div class="text0 education">
           Unified Objects, Inc. 
         </div> 
         <div class="text0 linkit"> 
          <a target="_blank" href="http://www.unifiedobjects.com/">http://www.unifiedobjects.com/</a> 
         </div> 
         <div class="text0">
           +1.(844) 440-7400 
         </div> 
         <div class="text0">
           info@unifiedobjects.com 
         </div> 
         <div class="text0">
           215 Water St 
         </div> 
         <div class="text0">
           St. John's, NL 
         </div> 
         <div class="text0 extra">
           Canada 
         </div> 
         <div> 
          <div class="w-form"> 
  
  <form
     id="email-form"
     name="email-form">

            <div class="d1"> 
  
  <input
     type="text"
     class="e1 w-input"
     autofocus="true"
     maxlength="256"
     name="Name-2"
     placeholder="NAME"
     id="Name-2"
     required>

            </div> 
            <div class="d1 d2 text0"> 
  
  <input
     type="email"
     id="Email-2"
     name="Email-2"
     placeholder="EMAIL"
     maxlength="256"
     class="e1 e2 w-input"
     required>

            </div> 
            <div class="d1 d2 d3"> 
  
  <textarea
     id="Message-2"
     name="Message-2"
     placeholder="MESSAGE"
     maxlength="5000"
     data-name="Message 2"
     class="e1 e2 e3 text0 w-input"
     required>

             </textarea> 
            </div> 
            <input type="submit" value="SEND" class="div2 s3 w-button"> 
           </form> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="text1 text16">
     PERRY ANDERSON: IT CONSULTANT PORTFOLIO 
   </div> 
  </div> 
 </div> 
 <div class="linked"> 
  <a href="https://github.com/perriera?tab=projects" target="_blank" class="w-inline-block"><img src="assets/images/Octocat.png" sizes="44px" srcset="assets/images/Octocat.png 500w, assets/images/Octocat.png 800w" alt="" class="image"></a> 
  <a href="https://www.linkedin.com/in/perryanderson" target="_blank" class="w-inline-block"><img src="assets/images/index.png" alt="" srcset=""></a> 
  <a href="https://www.facebook.com/perry.anderson.969" target="_blank" class="w-inline-block"><img src="assets/images/index2.png" alt="" srcset=""></a> 
  <a href="https://www.simplilearn.com/pgp-data-science-certification-bootcamp-program" target="_blank" class="w-inline-block"><img src="assets/images/8xPxraAg_400x400.jpg" alt="" class="image" srcset=""></a> 
 </div> 
 <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=565ccc916473f20270135af5" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>

